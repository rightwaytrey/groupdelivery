#!/bin/bash
#
# Group Delivery - One-Command VPS Deployment
#
# This script will:
# - Install Docker if needed
# - Prompt for configuration (domain, admin user)
# - Generate SSL certificates automatically via Caddy
# - Deploy the complete application
#
# Usage: sudo ./deploy.sh
#

set -e

# Config file for saved settings
CONFIG_FILE=".deploy-config"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "\n${BLUE}================================================${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}================================================${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Load saved config
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Save config
save_config() {
    cat > "$CONFIG_FILE" << EOF
# Deployment configuration
# Generated on $(date)
DOMAIN=$1
EOF
    chmod 600 "$CONFIG_FILE"
    print_success "Saved configuration to $CONFIG_FILE"
}

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    print_error "Please run as root (use sudo)"
    exit 1
fi

print_header "Group Delivery - VPS Deployment"

# Check if Docker is installed
print_header "Checking Docker Installation"

if ! command -v docker &> /dev/null; then
    print_warning "Docker not found. Installing Docker..."

    # Update package index
    apt-get update -qq

    # Install prerequisites
    apt-get install -y -qq ca-certificates curl gnupg lsb-release

    # Add Docker's official GPG key
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg

    # Set up Docker repository
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

    # Install Docker
    apt-get update -qq
    apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # Start Docker
    systemctl start docker
    systemctl enable docker

    print_success "Docker installed successfully"
else
    print_success "Docker is already installed"
fi

# Verify docker compose
if ! docker compose version &> /dev/null; then
    print_error "Docker Compose plugin not found"
    exit 1
fi

print_success "Docker Compose is available"

# Prompt for configuration
print_header "Configuration"

# Load saved configuration
load_config

# Domain name
if [ -n "$DOMAIN" ]; then
    print_warning "Previously saved domain: $DOMAIN"
    read -p "Press Enter to use this domain, or type a new domain: " NEW_DOMAIN
    if [ -n "$NEW_DOMAIN" ]; then
        DOMAIN="$NEW_DOMAIN"
    fi
else
    read -p "Enter your domain name (e.g., delivery.example.com): " DOMAIN
fi

if [ -z "$DOMAIN" ]; then
    print_error "Domain name is required"
    exit 1
fi

# Generate configuration files
print_header "Generating Configuration"

# Generate secure secret key
SECRET_KEY=$(openssl rand -hex 32)

# Create .env file
cat > .env << EOF
# Generated by deploy.sh on $(date)

# Security
SECRET_KEY=${SECRET_KEY}

# External Services
OSRM_HOST=http://router.project-osrm.org
GEOCODING_PROVIDER=nominatim
GEOCODING_API_KEY=

# Domain
DOMAIN=${DOMAIN}
EOF

print_success "Created .env file"

# Create Caddyfile from template
if [ ! -f "Caddyfile.template" ]; then
    print_error "Caddyfile.template not found"
    exit 1
fi

sed "s/DOMAIN_PLACEHOLDER/${DOMAIN}/g" Caddyfile.template > Caddyfile
print_success "Created Caddyfile with domain: $DOMAIN"

# Save configuration
save_config "$DOMAIN"

# Create data directory
mkdir -p data
chmod 755 data
print_success "Created data directory"

# Deploy application
print_header "Deploying Application"

# Stop any running containers
if docker compose -f docker-compose.prod.yml ps -q 2>/dev/null | grep -q .; then
    print_warning "Stopping existing containers..."
    docker compose -f docker-compose.prod.yml down
fi

# Build and start containers
print_warning "Building and starting containers (this may take a few minutes)..."
docker compose -f docker-compose.prod.yml up -d --build

# Wait for backend to be ready
print_warning "Waiting for backend to be ready..."
sleep 10

# Check if backend is healthy
max_attempts=30
attempt=0
while [ $attempt -lt $max_attempts ]; do
    if docker exec groupdelivery-backend curl -f http://localhost:8000/api/health &>/dev/null; then
        print_success "Backend is ready"
        break
    fi
    attempt=$((attempt + 1))
    sleep 2
done

if [ $attempt -eq $max_attempts ]; then
    print_error "Backend failed to start properly"
    print_warning "Check logs with: docker compose -f docker-compose.prod.yml logs backend"
    exit 1
fi

# Create admin user (if needed)
print_header "Admin User Setup"

# Check if admin already exists
print_warning "Checking for existing admin user..."
if docker exec -i groupdelivery-backend python /app/check_admin.py >/dev/null 2>&1; then
    print_success "Admin user already exists - skipping admin creation"
else
    print_warning "No admin user found - creating admin user"

    # Admin username
    read -p "Enter admin username: " ADMIN_USER
    if [ -z "$ADMIN_USER" ]; then
        print_error "Admin username is required"
        exit 1
    fi

    # Admin password
    while true; do
        read -s -p "Enter admin password: " ADMIN_PASS
        echo
        read -s -p "Confirm admin password: " ADMIN_PASS_CONFIRM
        echo

        if [ "$ADMIN_PASS" = "$ADMIN_PASS_CONFIRM" ]; then
            if [ ${#ADMIN_PASS} -lt 8 ]; then
                print_error "Password must be at least 8 characters"
                continue
            fi
            break
        else
            print_error "Passwords do not match"
        fi
    done

    # Admin email
    read -p "Enter admin email: " ADMIN_EMAIL
    if [ -z "$ADMIN_EMAIL" ]; then
        ADMIN_EMAIL="${ADMIN_USER}@${DOMAIN}"
        print_warning "Using default email: $ADMIN_EMAIL"
    fi

    # Create the admin user
    docker exec groupdelivery-backend python /app/create_admin.py "$ADMIN_USER" "$ADMIN_EMAIL" "$ADMIN_PASS"
fi

# Final instructions
print_header "Deployment Complete!"

echo -e "${GREEN}Your Group Delivery application is now running!${NC}\n"
echo -e "Access your application at:"
echo -e "  ${BLUE}https://${DOMAIN}${NC}\n"
echo -e "Admin credentials:"
echo -e "  Username: ${YELLOW}${ADMIN_USER}${NC}"
echo -e "  Email: ${YELLOW}${ADMIN_EMAIL}${NC}\n"
echo -e "Important DNS Configuration:"
echo -e "  Make sure ${YELLOW}${DOMAIN}${NC} points to this server's IP address"
echo -e "  Caddy will automatically obtain SSL certificates from Let's Encrypt\n"
echo -e "Useful commands:"
echo -e "  View logs:        ${BLUE}docker compose -f docker-compose.prod.yml logs -f${NC}"
echo -e "  Restart:          ${BLUE}docker compose -f docker-compose.prod.yml restart${NC}"
echo -e "  Stop:             ${BLUE}docker compose -f docker-compose.prod.yml down${NC}"
echo -e "  Update & restart: ${BLUE}docker compose -f docker-compose.prod.yml up -d --build${NC}\n"

print_warning "Note: It may take 1-2 minutes for SSL certificates to be issued"
print_warning "Make sure your domain's DNS is properly configured before accessing via HTTPS"
